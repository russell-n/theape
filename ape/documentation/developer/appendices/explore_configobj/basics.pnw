Basic ConfigObj
===============

Here we'll look at using ConfigObj to parse a user's configuration file.

<<name='imports', wrap=False>>=
# python standard library
from StringIO import StringIO

# third party
from configobj import ConfigObj
@

The ConfigObj object inherits from the configobj.Section class which itself extends python's `dict`.

.. uml::

   dict <|-- Section
   Section <|-- ConfigObj

So most retrievals will look like you're using a dictionary of dictionaries.

Root Options
------------

Unlike python's ConfigParser, ConfigObj lets you put values in the configuration with no section header.

<<name='root_options'>>=
sample = ["name = John Bigboote"]

config = ConfigObj(sample)
print config['name']
@

ConfigObj also supports comma-separated lists by default.

<<name='string_lists'>>=
sample = ["diseases = ebola, syphillis, cooties"]
config = ConfigObj(sample)
print config['diseases']
@

What if your value has a comma?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<<name='quote'>>=
sample = ["quote = What's this, then?"]
config = ConfigObj(sample)
print config['quote']
@

In this case you can set the `list_values` parameter to False

<<name='unlist'>>=
config = ConfigObj(sample, list_values=False)
print config['quote']
@

.. note:: This parameter has to be set in the constructor, changing the objects 'list_values' attribute won't work.

<<name='unlist_experiment'>>=
config = ConfigObj(sample)
config.list_values = False
print config['quote']
@

This makes it difficult to have cases where you have lists and non-lists in the same configuration. It's probably better to let the validation take care of converting values to non-strings.


Sections and Sub-Sections
-------------------------

ConfigObj handles sections much like ConfigParser so can be used where the configuration follows the ini-format.

<<name='sections'>>=
sample = StringIO("""
default = this
[grape]
name = ape
value = 1
""")

config = ConfigObj(sample)
print config
@

Looking at the output you can see that adding sections adds an inner dictionary. To access the values you still use the dict interface.

<<name='section_values'>>=
print config['default']
print config['grape']['name']
print config['grape']['value']
@

To add more structure to the configuration you can also add sub-sections by adding more brackets around the headers.

<<name='subsections'>>=
sample = StringIO("""
[top]
top_value = 0
  [[level1]]
  level1_value = 1

    [[[level2]]]
    level2_value = 2

[topcow]
topcow_value = moo
""")
config = ConfigObj(sample)

print "Top Value: ", config['top']['top_value']
print "Level1 Value", config['top']['level1']['level1_value']

print "Level2 Value", config['top']['level1']['level2']['level2_value']

print "Top Cow: ", config['topcow']['topcow_value']

@