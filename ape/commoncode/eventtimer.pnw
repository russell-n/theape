EventTimer
==========

Contents:

    * :ref:`The EventTimer <ape-event-timer>`

    * :ref:`The Wait Decorator <ape-wait-decorator>`

<<name='constants', echo=False>>=
IN_PWEAVE = __name__ == "__builtin__"
@
<<name='imports', echo=False>>=
# this package
from ape import BaseClass
from ape.commoncode.code_graphs import  module_diagram, class_diagram
@

.. _ape-event-timer:

The Event Timer
---------------

An EventTimer will block if you try to make a new request too soon (too soon being something that needs to be empirically determined by the user). It was originally created to prevent calls to a (slow) AP's http server from trying `GET` requests too frequently, as that caused the server to timeout. I think that it will be more useful here as a way to provide even intervals to things that have to make calls at certain times (e.g. code that watches a proc-file).

.. '

.. uml::

   EventTimer o- threading.Event
   EventTimer o- threading.Timer
   EventTimer -|> BaseClass
   EventTimer : __init__(event, seconds)   

.. currentmodule:: ape.commoncode.eventtimer
.. autosummary::
   :toctree: api

   EventTimer
   EventTimer.event
   EventTimer.timer
   EventTimer.set_event
   EventTimer.start
   EventTimer.clear
   EventTimer.wait

<<name='EventTimer', echo=False>>=
class EventTimer(BaseClass):
    """
    A timer object to set an event
    """
    def __init__(self, seconds=0.5, event=None):
        """
        EventTimer constructor

        :param:

         - `event`: a threading.Event to set
         - `seconds`: number of seconds to run the timer
        """
        self._event = event
        self.seconds = seconds
        self._timer = None
        return

    @property
    def event(self):
        """
        Threading event for the timer to set
        """
        if self._event is None:
            self._event = threading.Event()
            # I don't know about this, but I think
            # I want it to always rely on the timer to clear it
            self._event.set()
        return self._event

    @property
    def timer(self):
        """
        A threading.Timer object
        """
        # Timers can only be started once, so this can't be persistent
        return threading.Timer(self.seconds, self.set_event)

    def set_event(self):
        """
        Sets the event
        """
        self.event.set()
        return

    def start(self):
        """
        The main interface - clears the event then starts the timer
        """
        self.event.clear()
        self.timer.start()
        return

    def clear(self):
        """
        A convenience method for users to call the event.clear method.        
        """
        self.event.clear()
        return

    def wait(self, timeout=None):
        """
        Calls event.wait if timeout is None, uses self.seconds
        """
        if timeout is None:
            timeout = self.seconds
        self.event.wait(timeout)
        return            
# end class EventTimer        
@

A Class Diagram
~~~~~~~~~~~~~~~

An auto-generated class diagram.

<<name='class_diagram', echo=False, wrap=False, results='sphinx'>>=
if IN_PWEAVE:
    import os
    this_file = os.path.join(os.getcwd(), 'eventtimer.py')
    class_diagram_file = class_diagram(class_name="EventTimer",
                                       filter='OTHER',
                                       module=this_file)
    print ".. image:: {0}".format(class_diagram_file)
@

.. _ape-wait-decorator:

The ``wait`` Decorator
----------------------

To make using the ``EventTimer`` easier, you can use the ``wait`` decorator. What it does:

    #. Call event.wait in case a previous timer is still running

    #. Clear the event

    #. Call the decorated method

    #. Start the timer

Basic Use::

   @wait
   def do_something(self):
       # do something here after the event-timer expires
       return

.. warning:: This is a method decorator -- it assumes the object it belongs to has a :ref:`timer <ape-event-timer>` property.

.. autosummary::
   :toctree: api

   wait
   
<<name='wait_decorator', echo=False>>=
def wait(method):
    """
    Decorator to wait for previous timers and to start a new one on exit

    :param:

     - `method`: method to wrap with a timer.wait call

    :return: wrapped method
    """
    def _method(self, *args, **kwargs):
        # wait if timer is running but only up until the time-limit
        self.timer.wait(self.timer.seconds)
        self.timer.clear()
        outcome = method(self, *args, **kwargs)
        self.timer.start()
        return outcome
    return _method                
@

Module Diagram
--------------

A module diagram for this module.

<<name='module_diagram', echo=False, wrap=False, results='sphinx'>>=
if IN_PWEAVE:
    module_diagram_file = module_diagram(module=this_file, project='eventtimer')
    print ".. image:: {0}".format(module_diagram_file)
@

An Example
----------

As a basic example, suppose you want to print 'Able was I ere I saw Elba' every second. You could do something like this::

    class Napolean(object):
        def __init__(self):
            self.timer = EventTimer(seconds=1)
            

        @wait
        def __call__(self):
            print 'Able was I ere I saw Elba'
            return

And this would print the palindrome with 1 second pauses in between::

    speak = Napolean()
    speak()

