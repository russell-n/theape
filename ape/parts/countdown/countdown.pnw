The Countdown
=============

The Countdown Timers are meant to be used by the composites and components to keep track of elapsed (and sometimes remaining) time. The :ref:`Time Tracker <ape-parts-countdown-timetracker>` is used to keep track of how long execution is taking. This is meant primarily for someone wanting to estimate future times by looking at past logs. The :ref:`CountDown Timer <ape-parts-countdown-countdowntimer>` also keeps track of execution time but is meant to also keep track of whether the composite should repeat or not (based on remaining repetitions or time).

Contents:

    * :ref:`TimeTracker <ape-parts-countdown-timetracker>`

    * :ref:`CountdownTimer <ape-parts-countdown-countdowntimer>`


.. currentmodule:: ape.parts.countdown.countdown

<<name='imports', echo=False>>=
# python standard library
import datetime
from datetime import timedelta

# third party
import numpy

# this package
from ape import BaseClass, ApeError
@

<<name='constants', echo=False>>=
DEBUG = 'debug'
INFO = 'info'
STAT_STRING = 'Min: {min}, Q1: {q1}, Med: {med}, Q3: {q3}, Max: {max}, Mean: {mean}, StD: {std}'
ELAPSED_STRING = 'Elapsed: {0}'
@

.. _ape-parts-countdown-timetracker:

The TimeTracker
---------------

Responsibilities
~~~~~~~~~~~~~~~~

The TimeTracker:

    * Tracks start time, stop time, elapsed times

    * Logs min, Q1, median, Q3, max elapsed times

    * Returns True when running and False when stopped at __call__

The Model
~~~~~~~~~

.. uml::

   BaseClass <|-- TimeTracker
   TimeTracker : Bool __call__()
   TimeTracker : start
   TimeTracker : elapsed_times
   TimeTracker : __init__(log_level)

.. currentmodule:: ape.parts.countdown.countdown
.. autosummary::
   :toctree: api

   TimeTracker

   
<<name='TimeTracker', echo=False>>=
class TimeTracker(BaseClass):
    """
    A tracker of elapsed time
    """
    def __init__(self, log_level=DEBUG):
        """
        TimeTracker constructor

        :param:

         -  `log_level`: level at which to report elapsed times
        """
        super(TimeTracker, self).__init__()
        self.log_level = log_level
        self.start = None
        self.times = []
        self._log = None
        return

    @property
    def log(self):
        """
        The logger method indicated by the log_level

        :return: logger.debug or logger.info
        """
        if self._log is None:
            if self.log_level == INFO:
                self._log = self.logger.info
            elif self.log_level == DEBUG:
                self._log = self.logger.debug
            else:
                raise ApeError("Unknown log level: {0}".format(self.log_level))
        return self._log
        

    def append(self, item):
        """
        Appends the item to the times array

        :param:

         - `item`: item to append to self.times (a numpy array)

        :postcondition: self.times contains item
        """
        self.times = numpy.append(self.times, [item])
        return

    def percentile(self, percentile):
        """
        calculates the percentile (e.g. 50 gets the median (the 50% item))

        :return: value for percintile of self.times as a timedelta
        """
        return timedelta(seconds=numpy.percentile(self.times, percentile))

    def __call__(self):
        """
        The main interface - starts and stops (toggles) the timer

        :return: True if starting, False if stopping
        :postcondition: elapsed time logged and added to self.times
        """
        if self.start is None:
            self.start = datetime.datetime.now()            
            return True
        elapsed = datetime.datetime.now() - self.start
        # numpy can't handle timedeltas
        self.append(elapsed.total_seconds())
        self.start = None
        self.log(ELAPSED_STRING.format(elapsed))
        self.log(STAT_STRING.format(min=self.percentile(0),
                                    q1=self.percentile(24),
                                    med=self.percentile(50),
                                    q3=self.percentile(75),
                                    max=self.percentile(100),
                                    mean=timedelta(seconds=numpy.mean(self.times)),
                                    std=timedelta(seconds=numpy.std(self.times))))
        return False
@

The expected way to use the TimeTracker is as a sentinal in a while loop::

   
   def run(self):
       # assumes self.t is a TimeTracker instance
       while self.t():
           time.sleep(1)
       return

This would append a timedelta of about 1 second to the TimeTracker's times array everytime ``run`` is called, and log the current elapsed time and the basic running statistics (which in this case shouldn't show any variance)

The Countdown
-------------

The CountDown keeps track of elapsed time and estimates remaining time either by repetitions or total allowed time.

.. uml::

   CountDown -|> BaseClass

.. autosummary::
   :toctree: api

   CountDown
   CountDown.start_timer
   CountDown.next_iteration
   CountDown.remaining_time
   CountDown.remaining_iterations
   CountDown.elapsed_time

To start off it will only take expected iterations and estimate time-remaining based on time elapsed. 
   
<<name='CountDown', echo=False>>=
class CountDown(BaseClass):
    """
    A countdown timer
    """
    def __init__(self, iterations, *args, **kwargs):
        """
        CountDown Constructor

        :param:

         - `iterations`: Number of expected iterations.
        """
        super(CountDown, self).__init__(*args, **kwargs)
        self.iterations = iterations
        self.iteration = 0
        return

    @property
    def time_remaining(self):
        """
        An estimate of the time remaining
        """
        return self.iterations - self.iteration

    def start_timer(self):
        """
        Sets the start_time and lap_start_time to now
        """
        self.start_time = datetime.datetime.now()
        self.lap_start_time = self.start_time
        return

    def next_iteration(self):
        """
        Increments the iterations and saves the lap-time
        """
        self.iteration += 1
        return
# end class CountDown
@
<<name='test_imports', echo=False>>=
# python standard library
import unittest
@
<<name='TestCountDown', echo=False>>=
class TestCountDown(unittest.TestCase):
    def setUp(self):
        self.iterations = 4
        self.counter = CountDown(iterations=self.iterations)
        return

    def test_next_iteration(self):
        """
        Does it increment the iteration
        """
        self.assertEqual(self.iterations, self.counter.iterations)
        for value in xrange(self.iterations):
            self.counter.next_iteration()
            self.assertEqual(value+1, self.counter.iteration)
        self.assertEqual(0, self.counter.time_remaining)
        return
@
<%
for case in (TestCountDown, ):
    suite = unittest.TestLoader().loadTestsFromTestCase(case)    
    unittest.TextTestRunner(verbosity=2).run(suite)
%>
