The Components
==============

.. _the-components:

Contents:

    * :ref:`Introduction <components-introduction>`
    * :ref:`Component Module Diagram <component-module-diagram>`
    * :ref:`The Component Class <component-class>`
    * :ref:`The Composite Class <composite-class>`

.. _components-introduction:
Introduction
------------

This is a module to hold classes that (loosely) implement the `Composite Pattern <http://en.wikipedia.org/wiki/Composite_pattern>`_. See the :ref:`Ape Plugin <ape-plugin>` for how the Composites are being used in the `ape` (it is implemented in the `product` property).

<<name='imports', echo=False>>=
# python standard library
from abc import abstractmethod, ABCMeta, abstractproperty
import inspect
import os

# this package
from ape import BaseClass
from ape import ApeError
from ape.parts.countdown.countdown import CountDown
from ape.commoncode.strings import RESET, BLUE
from ape.commoncode.strings import BOLD, BOLD_THING, RED
from ape.commoncode.crash_handler import try_except
from ape.commoncode.errors import ConfigurationError
from ape.commoncode.code_graphs import module_diagram, class_diagram
@
<<name='constants', echo=False>>=
DOCUMENT_THIS = __name__ == '__builtin__'
@

.. _component-module-diagram:
Module Diagram
--------------

This is an auto-generated graph of the classes in this module.

<<name='module_graph', echo=False, results='sphinx'>>=
if DOCUMENT_THIS:
    this_file = os.path.join(os.getcwd(), 'component.py')
    module_diagram_file = module_diagram(module=this_file, project='composite')
    print ".. image:: {0}".format(module_diagram_file)
@


.. _component-class:
The Component Class
-------------------

This is the base-class which the other classes will inherit from. All :ref:`Plugin products <base-plugin-product>` should look like this (it doesn't do much so I'm not sure if it's worth it to enforce inheritance).

.. superfluous '

.. uml::

   Component -|> BaseClass
   Component : __call__()
   Component : check_rep()
   Component : close()

.. currentmodule:: ape.components.component
.. autosummary::
   :toctree: api

   Component
   Component.__call__
   Component.check_rep
   Component.close

<<name='Component', echo=False>>=
class Component(BaseClass):
    """
    A base-class for Composite and Leaf
    """
    __metaclass__ = ABCMeta
    def __init__(self):
        super(Component, self).__init__()
        self._logger = None
        return

    @abstractmethod
    def __call__(self):
        """
        abstractmethod that will be the main invocation when implememented
        """
        return

    @abstractmethod
    def check_rep(self):
        """
        abstract: Representation-check called by composite

        :raise: ConfigurationError if representation invalid
        """
        return

    @abstractmethod
    def close(self):
        """
        abstractmethod: called for Keyboard Interrupts to allow file-closing
        """
        return
@


This is an autogenerated version of the class-diagram.

<<name='class_diagram', echo=False, results='sphinx'>>=
if DOCUMENT_THIS:
    class_diagram_file = class_diagram(class_name="Component",
                                       filter='OTHER',
                                       module=this_file)
    print ".. image:: {0}".format(class_diagram_file)
@

.. _composite-class:
The Composite
-------------

.. uml::

   Composite -|> Component

.. autosummary::
   :toctree: api

   Composite
   Composite.components
   Composite.add
   Composite.remove
   Composite.__call__
   Composite.__iter__
   Composite.__len__
   Composite.__getitem__
   Composite.one_call
   Composite.check_rep
   Composite.close

The `Composite` is a generalization of the `Hortator`, `Operator` and `Operations`. By specifying the error that it will catch, the error message it will display if there is one, its components, and the component-category of its components, you specify what type of composite it is.

 * Each component call is wrapped by the :ref:`try_except decorator <try-except-decorator>` which catches the Exception in self.error
   
<<name='Composite', echo=False>>=
class Composite(Component):
    """
    A Composite to hold and execute Components
    """
    def __init__(self, error=None, error_message=None,
                 identifier=None,
                 component_category=None,
                 is_root=False):
        """
        Composite Constructor

        :param:

         - `error`: Exception to catch when calling components
         - `error_message`: string for header of error messages
         - `component_category`: label for error messages when reporting component actions
         - `identifier`: something to identify this when it starts the call
         - `is_root`: if True logs summation information
        """
        super(Composite, self).__init__()
        self.error = error
        self.error_message = error_message
        self.identifier = identifier
        self.component_category = component_category
        self.is_root = is_root
        self._logger = None
        self._components = None
        return

    @property
    def components(self):
        """
        The list of components
        """
        if self._components is None:
            self._components = []
        return self._components

    def add(self, component):
        """
        appends the component to self.components

        :param:

         - `component`: A Component

        :postcondition: component appended to components
        """
        # using is instead of in in case __eq__ overriden
        for existing_component in self.components:
            if component is existing_component:
                return
        self.components.append(component)
        return

    def remove(self, component):
        """
        Removes the component from the components (if it was there)
        """
        try:
            self.components.remove(component)
        except ValueError as error:
            self.logger.debug(error)
        return

    def __iter__(self):
        """
        Iterates over the components
        """
        for component in self.components:
            yield component

    def __len__(self):
        """
        Counts the components

        :return: count of components
        """
        return len(self.components)

    def __getitem__(self, index):
        """
        gets slice or index of components
        """
        return self.components[index]

    @try_except
    def one_call(self, component):
        """
        Calls the  component (pulled out into a method to catch the exceptions)

        :raise:

         - `ApeError` if component is not callable
        """
        if not hasattr(component, '__call__'):
            raise ApeError(("'{0}' has not implemented the __call__ interface. " 
                            "What a way to run a railroad.").format(component.__class__.__name__))
        component()
        return

    def __call__(self):
        """
        The main interface -- starts components after doing a check_rep

        """
        self.logger.debug("{b}** Checking the Composite Class Representation **{r}".format(b=BOLD,
                                                                                          r=RESET))
                                                                                          
        self.check_rep()
        count_string = "{b}** {l} {{c}} of {{t}} ('{{o}}') **{r}".format(b=BOLD, r=RESET,
                                                                         l=self.component_category)

        self.logger.info("{b}*** {c} Started ***{r}".format(b=BOLD, r=RESET,
                                                             c=self.identifier))
        
        total_count = len(self.components)
        
        self.logger.info("{b}*** Starting {c} ***{r}".format(b=BOLD, r=RESET,
                                                             c=self.component_category))
        
        for count, component in enumerate(self.components):
            self.logger.info(count_string.format(c=count+1,
                                                 t=total_count,
                                                 o=str(component)))                                                 
            self.one_call(component)
            
        self.logger.info("{b}*** {c} Ended ***{r}".format(b=BOLD, r=RESET,
                                                             c=self.identifier))        
        return

    def check_rep(self):
        """
        Checks the representation invariant     

        :raise: ConfigurationError
        """
        try:
            assert inspect.isclass(self.error),(
                "self.error must be an exception, not {0}".format(self.error))
            assert issubclass(self.error, Exception),(
                "self.error needs to be an exception, not {0}".format(self.error))
            assert self.error_message is not None, (
                "self.error_message must not be None")
            assert self.component_category is not None, (
                "self.component_category must not be None")

            # check all your children
            for component in self.components:
                if hasattr(component, 'check_rep'):
                    component.check_rep()
                else:
                    self.log_error(error="'{0}' hasn't implemented the 'check_rep' method.".format(component.__class__.__name__),
                                    message="Thanks for the sour persimmons, cousin.")

        except AssertionError as error:
            raise ConfigurationError(str(error))
        return

    def close(self):
        """
        calls the `close` method on each component

        """
        for component in self.components:
            if hasattr(component, 'close'):
                component.close()
            else:
                self.logger.warning("'{0}' hasn't implemented the 'close' method. We hate him.".format(component.__class__.__name__))
        return

    def __str__(self):
        return ("{2} -- Traps: {0}, "
                "{3} Components: {1}").format(self.error.__name__,
                                         self.component_category,
                                         self.__class__.__name__,
                                         len(self.components))
        
#end class Composite
@

<<name='composite_class_diagram', echo=False, results='sphinx'>>=
if DOCUMENT_THIS:
    class_diagram_file = class_diagram(class_name="Composite",
                                       filter='OTHER',
                                       module=this_file)
    print ".. image:: {0}".format(class_diagram_file)
@

