The Base Plugin
===============
.. currentmodule:: ape.plugins.base_plugin
<<name='imports', echo=False>>=
# python standard library
from abc import ABCMeta, abstractmethod, abstractproperty
import os
from types import StringType

# third party
from configobj import ConfigObj, flatten_errors, get_extra_values
from validate import Validator

# this package 
from ape.infrastructure.baseclass import BaseClass
from ape.parts.helppage.helppage import HelpPage
from ape.infrastructure.code_graphs import module_diagram, class_diagram
@
<<name='check_pweave', echo=False>>=
in_pweave = __name__ == '__builtin__'
@

.. _base-plugin:

Background
----------

This module contains a `BasePlugin` class that forms the foundation of the `ape` plugin-system. Creating a `BasePlugin` makes it easier to add code as it provides a concrete target for the person adding the code, removes the need for the infrastructure code to be changed when plugins are added, and encourages documentation by providing a built-in online help-interface and auto-included `rst` files.

In order to create a child of the `BasePlugin` you are required to implement two properties and one method: ``sections``, ``product``, and ``fetch_config()``. The ``sections`` and ``fetch_config`` are for the user-interface while the ``product`` should be the object to run. The ``sections`` can be ``None`` if you do not want the online help, but should otherwise be a dictionary with section-names as keys and content-strings as values. It will be passed to the :ref:`HelpPage <help-page>` so you should see that if you want to know what will be done with the ``sections`` property. If the ordering is important use a ``collections.OrderedDict``. The
``fetch_config`` is expected to be a method that sends a sample config-file snippet to stdout. I chose stdout rather than to disk because it allows the user to append it to existing files using redirection ``>>`` and it also serves as a prompt for those who just need to remember what the configuration should look like (I also had problems with users accidentally clobbering their configurations by pulling sample files). The ``product`` should be the built-object for the code to run (only the ``__call__`` method will be used so that has to be implemented on the ``product``). When the child-plugin is implemented, it will be passed a `ConfigObj`.

The :ref:`QuarterMaster <quarter-master>` looks for child-classes of the `BasePlugin` when deciding what is a valid plugin, so besides defining an implementation expectation for the new plugin, the `BasePlugin` also provides the means for inclusion in the `ape` (even if you drop a module in this folder, if nothing in it is a child of the `BasePlugin` it will be ignored). To check if it contains a `BasePlugin` the module has to be imported so be careful with globals and imports.

The `BasePlugin` class and the ``plugins`` package also provides the foundation for user help. As noted above, the ``sections`` and ``fetch_config`` are meant for online help and in addition to this the ``index.pnw`` file contains code to include any ``rst`` files in the ``plugins`` directory so adding documentation files here will add the text to the documentation when it is regenerated::

   Pweave index.pnw

To summarize, the `BasePlugin` is the main way to add code that will be exposed to the end user.

.. warning:: I have had a lot of problems troubleshooting when I accidentally name plugin-class the same thing as (one of) the class(es) it's building -- the re-definition of the name will wipe out your imported name. Don't do it. (e.g. don't create a plugin named Sample that builds a class named Sample as its product.)

.. '

Class Diagram
-------------

This is an (idealized) class diagram (see below for an auto-generated one).
    
.. uml::

   BaseClass <|-- BasePlugin
   BaseClass : logger
   BasePlugin : configuration
   BasePlugin o- HelpPage
   BasePlugin : sections
   BasePlugin : product
   BasePlugin : help(width)
   BasePlugin : fetch_config()
   BasePlugin : section_header

Public Properties and Methods
-----------------------------

The following are the public propeties and methods. The ``help_page`` and ``help()`` are the only implemented attributes, the rest need to be implemented by the inheriting classes.

.. _base-plugin-sections:
Sections
~~~~~~~~

The `sections` are a dictionary used by the help-page to create the screen-output. By defining this dictionary you are defining what the user will see when they enter::

    ape help <plugin-name>

.. _base-plugin-product:
The Product
~~~~~~~~~~~

This is the built object that client code will call. To make the interface uniform it is assumed that all parameters have been set and none will be passed to the __call__() method.

.. _base-fetch-config::
The Fetch Config
~~~~~~~~~~~~~~~~

The `fetch_config` method used to copy an example configuration file to the current working directory (thus its name). Since each plugin can provide its own sample, I decided that they should instead output them to standard out. Thus the user could do something like this::

    ape fetch > ape.ini
    ape fetch IperfSession >> ape.ini

And so on to add to a configuration file without clobbering the old one. Additionally, the APE looks for a `config_glob` option in the APE section so the other configuration files could be put in a separate file and shared by other APE configurations.    
   
.. autosummary:: 
   :toctree: api

   BasePlugin
   BasePlugin.sections
   BasePlugin.help_page
   BasePlugin.help
   BasePlugin.product
   BasePlugin.fetch_config

Aggregated Classes
------------------

These are the classes that the BasePlugin uses.

.. currentmodule:: ape.commoncode.baseclass
.. autosummary::
   :toctree: api

   BaseClass.logger

.. currentmodule:: ape.parts.helppage.helppage
.. autosummary::
   :toctree: api

   HelpPage
   HelpPage.__call__
     
<<name='BasePlugin', echo=False>>=
class BasePlugin(BaseClass):
    """
    An abstract base-class for plugins

    :param:

     - `configuration`: configuration-map for plugin configuration
    """
    __metaclass__ = ABCMeta
    def __init__(self, configuration=None, section_header=None):
        """
        BasePlugin constructor

        :param:

         - `configuration`: a ConfigObj for the product
         - `section_header`: header in the configuration for this plugin's info
        """
        super(BasePlugin, self).__init__()
        self._logger = None
        self._help = None
        self._config = None
        self._product = None
        self._help_page = None        
        self._sections = None
        self.configuration = configuration
        self.section_header = section_header
        return

    @abstractproperty
    def sections(self):
        """
        A (ordered) dictionary for the help page
        """
        return self._sections

    @property
    def help_page(self):
        """
        A HelpPage to use if self.sections has been defined
        """
        if self._help_page is None and self.sections is not None:
            self._help_page = HelpPage(sections=self.sections)
        return self._help_page                        

    def help(self, width=80):
        """
        Prints a help-string for the plugin

        :param:

         - `width`: number of characters wide to print help
        """
        if self.sections is None:
            print "'{0}' offers you no help. Such is life.".format(self.__class__.__name__)
        else:
            self.help_page.wrap = width
            self.help_page()
        return

    @abstractproperty
    def product(self):
        """
        Abstract Property: The plugin (Component implementation)
        """
        return

    @abstractmethod
    def fetch_config(self):
        """
        Abstract Method: Get sample config-file snippet required by this plugin
        """
        return   
# end class BasePlugin                
@

.. Module Graph
.. ------------
.. 
.. <<name='module_graph', echo=False, results='sphinx'>>=
.. if in_pweave:
..     from ape.plugins.base_plugin import BasePlugin
..     print "This is a module diagram for **{0}**.\n".format(BasePlugin.__module__)
..     this_file = os.path.join(os.getcwd(), 'base_plugin.py')
..     module_diagram_file = module_diagram(module=this_file, project='baseplugin')
..     print ".. image:: {0}".format(module_diagram_file)
.. 
.. @

.. Class Diagram
.. -------------
.. 
.. This is an auto-generated diagram of the BasePlugin class.
..     
.. <<name='class_diagram', echo=False, results='sphinx'>>=
.. if in_pweave:
..     class_diagram_file = class_diagram(class_name="BasePlugin",
..                                        filter='OTHER',
..                                        module=this_file)
..     print ".. image:: {0}".format(class_diagram_file)
.. @

Base Configuration
------------------

BaseConfigurationConstants
~~~~~~~~~~~~~~~~~~~~~~~~~~

A holder of constants so other code can reference them.

<<name='BaseConfigurationConstants', wrap=False>>=
class BaseConfigurationConstants(object):
    """
    Holder of BaseConfiguration constants
    """
    __slots__ = ()
    plugin_option ='plugin'
    error_name = 'ConfigurationError'
    bad_option_message = "Option '{option}' in section '{section}' failed validation (error='{error}', should be {option_type})"
    missing_option_message = "Option '{option}' in section '{section}' of type {option_type} required but missing"
    missing_section_message = "Section '{section}' to configure '{plugin}' not found in configuration"
    extra_message = "Extra {item_type} in section '{section}. '{name}'"
@

The BaseConfiguration Abstract Base Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To handle the conversion to configobj, the product building should be handed over to a `Configuration` class.

.. uml::

   BaseClass <|-- BaseConfiguration

.. module:: ape.plugins.base_plugin
.. autosummary::
   :toctree: api   

   BaseConfiguration
   BaseConfiguration.configuration
   BaseConfiguration.product
   BaseConfiguration.configspec_source
   BaseConfiguration.configspec
   BaseConfiguration.configuration
   BaseConfiguration.section
   BaseConfiguration.plugin_name   
   BaseConfiguration.process_errors
   BaseConfiguration.outcome
   BaseConfiguration.check_extra_values

<<name='BaseConfiguration', echo=False>>=
class BaseConfiguration(BaseClass):
    """
    Abstract base class for configurations
    """
    __metaclass__ = ABCMeta
    def __init__(self, source, section_name, configspec_source=None):
        """
        BaseConfiguration constructor

        :param:

         - `source`: ConfigObj section
         - `section_name`: section-name in the configuration
         - `configspec_source`: list or file with configspec
        """
        super(BaseConfiguration, self).__init__()
        self.section_name = section_name
        self.source = source
        self._configspec_source = configspec_source
        
        self._product = None
        self._validator = None
        self._configspec = None
        self._configuration = None
        self._plugin_name = None
        self._section = None
        self._validation_outcome = None
        return

    @property
    def validation_outcome(self):
        """
        Outcome of validating the configuration
        """
        if self._validation_outcome is None:
            self._validation_outcome = self.configuration.validate(self.validator,
                                                                   preserve_errors=True)
        return self._validation_outcome

    @property
    def section(self):
        """
        Section extracted using self.section_name (if section_name not in config, sets to self.configuration)
        """
        if self._section is None:
            try:
                self._section = self.configuration[self.section_name]
            except KeyError as error:
                self.logger.debug(error)
                self._section = self.configuration
        return self._section

    @property
    def plugin_name(self):
        """
        Gets the plugin name from the section (or empty string if missing)
        """
        if self._plugin_name is None:
            try:
                self._plugin_name = self.section[BaseConfigurationConstants.plugin_option]
            except KeyError as error:
                self.logger.warning("'plugin' option missing in section '{0}'".format(self.section_name))
                self._plugin_name = ''
        return self._plugin_name

    @property
    def validator(self):
        """
        validator for the configuration
        """
        if self._validator is None:
            self._validator = Validator()
        return self._validator

    @property
    def configspec(self):
        """
        A configspec that  matches the Configuration
        """
        if self._configspec is None:
            # chicken-and-egg problem using configspec_source property
            # so I'm changing it here
            configspec_source = self.configspec_source
            if type(self.configspec_source) is StringType:
                # if source has string format option {section_name}
                # don't change the original because configuration property needs it
                configspec_source = self.configspec_source.format(section_name=self.section_name)
                configspec_source = configspec_source.splitlines()
            self._configspec = ConfigObj(configspec_source,
                                         list_values=False,
                                         _inspec=True)
        return self._configspec


    @property
    def configuration(self):
        """
        validates and sets the configuration using the source configuration

        :precondition: self.configspec has full configspec including section name
        :postcondition: self.source is validated configuration
        :postcondition: self.outcome is the outcome of the validation
        """
        if self._configuration is None:
            configuration = ConfigObj(self.source,
                                            configspec=self.configspec,
                                            file_error=True)
            #if 'updates_section' in configuration[self.section_name]:
            #
            #    other_section = configuration[self.section_name]['updates_section']
            #    configspec_source = self.configspec_source.format(section_name=other_section)
            #    configspec_source = configspec_source.splitlines()
            #    configspec = ConfigObj(configspec_source,
            #                           list_values=False,
            #                           _inspec=True)
            #    original_section = ConfigObj(self.source,
            #                                 configspec=configspec,
            #                                 file_error=True)
            #    original_section.merge(configuration)
            self._configuration = configuration            
            self._validation_outcome = self._configuration.validate(self.validator,
                                                                    preserve_errors=True)
        return self._configuration

    @abstractproperty
    def configspec_source(self):
        """
        Source for configuration specification (probably list of lines)
        """
        return

    @abstractproperty
    def product(self):
        """
        The object built from the configuration
        """
        return

    def process_errors(self):
        """
        logs the errors in outcome

        :param:

         - `outcome`: output of `validate` call
        """
        constants = BaseConfigurationConstants
        for sections, option, error in flatten_errors(self.configuration,
                                                      self.validation_outcome):
            section = ",".join(sections)
            if not section:
                section = self.section_name

            if option is not None: # something is wrong with the option
                # if there are sub-sections then the configspec has to be traversed to get the option-type
                spec = self.configspec
                for section in sections:
                    spec = spec[section]
                option_type = spec[option]
                
                if error: # validation of option failed                    
                    self.log_error(error=constants.error_name,
                                   message=constants.bad_option_message.format(option=option,
                                                                               section=section,
                                                                               error=error,
                                                                               option_type=option_type))
                else: # missing option
                    self.log_error(error=constants.error_name,
                                   message=constants.missing_option_message.format(option=option,
                                                                                   section=section,
                                                                                   option_type=option_type))
            else: # section missing
                print ",".join(sections)
                self.log_error(error=constants.error_name,
                               message=constants.missing_section_message.format(section=section,
                                                                                plugin=self.plugin_name))
        return

    def check_extra_values(self, warn_user=True):
        """
        checks the configuration for values not in the configspec

        :return: True if extra values, false otherwise
        """
        if warn_user:
            logger = self.logger.warning
        else:
            # in case the plugin doesn't care
            logger = self.logger.debug
            
        extra_values = get_extra_values(self.configuration)

        for sections, name in extra_values:
            # sections is a tuple of all the sections and subsections
            # leading to the option so we have to get to the bottom
            bottom_section = self.configuration
            for section in sections:
                bottom_section = bottom_section[section]

            # value is the extra item (either a value or section)
            value = bottom_section[name]
            
            item_type = 'option'
            if isinstance(value, dict):
                item_type = 'section'
            
            section = ','.join(sections) or "top level"
            message = BaseConfigurationConstants.extra_message.format(section=section,
                                                                    item_type=item_type,
                                                                    name=name)
            if item_type == 'option':
                message += "='{0}'".format(value)
            logger(message)
                
        return len(extra_values)
# end BaseConfiguration        
@










