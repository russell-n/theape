The Components
==============

.. _the-components:

Contents:

    * :ref:`Introduction <components-introduction>`
    * :ref:`Component Module Diagram <component-module-diagram>`
    * :ref:`The Component Class <component-class>`
    * :ref:`The Composite Class <composite-class>`

.. _components-introduction:
Introduction
------------

This is a module to hold classes that (loosely) implement the `Composite Pattern <http://en.wikipedia.org/wiki/Composite_pattern>`_. Rather than implementing separate classes for the different levels of Composites used in executing the `run` sub-command of the APE, a single composite is defined which accepts error and message specification (as well as component addition) to define the particular instance of the Composite.

.. uml::

   Component --|> BaseClass
   Composite --|> Component
   Leaf --|> Component
   Hortator --|> Composite
   Operator --|> Composite
   Operation --|> Composite
   Hortator "1" o- "1..*" Operator
   Operator "1" o- "1..*" Operation
   Operation "1" o- "1..*" Leaf

The `Hortator`, `Operator` and `Operation` aren't functionally different but they catch different levels of exceptions so that there can be a certain level of self-recovery and error handling. Each execution of the `ape` will have one `Hortator` composed of `Operators` (one `Operator` per configuration file with an `ARACHNEAPE` section). Each line in the ARACHNEAPE will correspond to an `Operation` composed of `Leafs` (one `Leaf` per item on the comma-separated line). Each Leaf will match one-to-one with a plugin's product. Thus when a plugin is created, the product should inherit from the `Component` class in order to make sure it has the same interface.

The reason for differentiating the three Composites is to allow different levels of error handling.  For instance, differentiating `Operation` vs  `Operator`  allows the user to decide on a set of plugin that will be called even if the first set crashes. e.g.::

    [ARACHNEAPE]
    op_1 = WatchRSSI,IperfSession
    op_2 = CleanUp

When translated to objects, this configuration would create one `Operation` composite for each line and both lines would be composed in an `Operator` (and if there are multiple config-files with [ARACHNEAPE] sections, each of the Operators will be composed in the Hortator). If one of the Leafs in `op_1` (WatchRSSI or IperfSession) crashes in a predictable way (raising an `ApeError`) then the `op_2` Leaf (CleanUp) should still be executed. The reason for only catching arachneape-defined exceptions is so that if something is really wrong with the code or system, it will be assumed that this configuration is un-runnable and the Hortator will move on to the next `Operator`.

<<name='imports', echo=False>>=
# python standard library
from abc import abstractmethod, ABCMeta, abstractproperty
import inspect
import os

# this package
from arachneape.commoncode.baseclass import BaseClass
from arachneape.parts.countdown.countdown import CountDown
from arachneape.commoncode.strings import RESET, BLUE
from arachneape.commoncode.strings import BOLD, BOLD_THING, RED
from arachneape.commoncode.crash_handler import try_except
from arachneape.commoncode.errors import ConfigurationError
from arachneape.commoncode.code_graphs import module_diagram, class_diagram
@
<<name='constants', echo=False>>=
DOCUMENT_THIS = __name__ == '__builtin__'
@

.. _component-module-diagram:
Module Diagram
--------------

This is an auto-generated graph of the classes in this module.

<<name='module_graph', echo=False, results='sphinx'>>=
if DOCUMENT_THIS:
    this_file = os.path.join(os.getcwd(), 'component.py')
    module_diagram_file = module_diagram(module=this_file, project='composite')
    print ".. image:: {0}".format(module_diagram_file)
@


.. _component-class:
The Component Class
-------------------

This is the base-class which the other classes will inherit from. All :ref:`Plugin products <base-plugin-product>` should look like this (it doesn't do much so I'm not sure if it's worth it to enforce inheritance).

.. superfluous '

.. uml::

   Component -|> BaseClass

.. currentmodule:: arachneape.components.component
.. autosummary::
   :toctree: api

   Component
   Component.__call__

<<name='Component', echo=False>>=
class Component(BaseClass):
    """
    A base-class for Composite and Leaf
    """
    __metaclass__ = ABCMeta
    def __init__(self):
        super(Component, self).__init__()
        self._logger = None
        return

    @abstractmethod
    def __call__(self):
        """
        abstractmethod that will be the main invocation when implememented
        """
        return
@


This is an autogenerated version of the class-diagram.

<<name='class_diagram', echo=False, results='sphinx'>>=
if DOCUMENT_THIS:
    class_diagram_file = class_diagram(class_name="Component",
                                       filter='OTHER',
                                       module=this_file)
    print ".. image:: {0}".format(class_diagram_file)
@

.. _composite-class:
The Composite
-------------

.. uml::

   Composite -|> Component

.. autosummary::
   :toctree: api

   Composite

The `Composite` is a generalization of the `Hortator`, `Operator` and `Operations`. By specifying the error that it will catch, the error message it will display if there is one, its components, and the component-category of its components, you specify what type of composite it is.

 * Each component call is wrapped by the :ref:`try_except decorator <try-except-decorator>` which catches the Exception in self.error
   
<<name='Composite', echo=False>>=
class Composite(Component):
    """
    A Composite to hold and execute Components
    """
    def __init__(self, error=None, error_message=None,
                 identifier=None,
                 component_category=None,
                 is_root=False):
        """
        Composite Constructor

        :param:

         - `error`: Exception to catch when calling components
         - `error_message`: string for header of error messages
         - `component_category`: label for error messages when reporting component actions
         - `identifier`: something to identify this when it starts the call
         - `is_root`: if True logs summation information
        """
        super(Composite, self).__init__()
        self.error = error
        self.error_message = error_message
        self.identifier = identifier
        self.component_category = component_category
        self.is_root = is_root
        self._logger = None
        self._components = None
        return

    @property
    def components(self):
        """
        The list of components
        """
        if self._components is None:
            self._components = []
        return self._components

    def add(self, component):
        """
        appends the component to self.components

        :param:

         - `component`: A Component

        :postcondition: component appended to components
        """
        # using is instead of in in case __eq__ overriden
        for existing_component in self.components:
            if component is existing_component:
                return
        self.components.append(component)
        return

    def remove(self, component):
        """
        Removes the component from the components (if it was there)
        """
        try:
            self.components.remove(component)
        except ValueError as error:
            self.logger.debug(error)
        return

    def __iter__(self):
        """
        Iterates over the components
        """
        for component in self.components:
            yield component

    def __len__(self):
        """
        Counts the components

        :return: count of components
        """
        return len(self.components)

    def __getitem__(self, index):
        """
        gets slice or index of components
        """
        return self.components[index]

    @try_except
    def one_call(self, component):
        """
        Calls the  component (pulled out into a method to catch the exceptions)
        """
        component()
        return

    def __call__(self):
        """
        The main interface -- starts components after doing a check_rep

        """
        self.logger.debug("{b}** Checking the Composite Class Representation **{r}".format(b=BOLD,
                                                                                          r=RESET))
        self.check_rep()
        count_string = "{b}** {l} {{c}} of {{t}} ('{{o}}') **{r}".format(b=BOLD, r=RESET,
                                                                         l=self.component_category)

        # countdown is going to be a plugin too
        #remaining_string = BOLD_THING.format(thing="Estimated Time Remaining:")
        #total_elapsed = BOLD_THING.format(thing='** Total Elapsed Time:')

        self.logger.info("{b}*** {c} Started ***{r}".format(b=BOLD, r=RESET,
                                                             c=self.identifier))
        
        total_count = len(self.components)
        
        self.logger.info("{b}*** Starting {c} ***{r}".format(b=BOLD, r=RESET,
                                                             c=self.component_category))
        
        for count, component in enumerate(self.components):
            self.logger.info(count_string.format(c=count+1,
                                                 t=total_count,
                                                 o=str(component)))
            self.one_call(component)
        self.logger.info("{b}*** Ending {c}s ***{r}".format(b=BOLD, r=RESET,
                                                            c=self.component_category))
        return

    def check_rep(self):
        """
        Checks the representation invariant

        :raise: ConfigurationError
        """
        try:
            assert inspect.isclass(self.error),(
                "self.error must be an exception, not {0}".format(self.error))
            assert issubclass(self.error, Exception),(
                "self.error needs to be an exception, not {0}".format(self.error))
            assert self.error_message is not None, (
                "self.error_message must not be None")
            assert self.component_category is not None, (
                "self.component_category must not be None")

            # check all your children
            for component in self.components:
                component.check_rep()

        except AssertionError as error:
            raise ConfigurationError(str(error))
        return

    def __str__(self):
        return ("{2} -- Traps Error: {0},"
                "Component Category: {1}").format(self.error.__name__,
                                                  self.component_category,
                                                  self.__class__.__name__)
        
#end class Composite
@

<<name='composite-class_diagram', echo=False, results='sphinx'>>=
if DOCUMENT_THIS:
    class_diagram_file = class_diagram(class_name="Composite",
                                       filter='OTHER',
                                       module=this_file)
    print ".. image:: {0}".format(class_diagram_file)
@


The Errors
----------

The hierarchy of errors is as follows:

.. uml::

   LeafError -|> ApeError


This is somewhat confusing so I will try to explain how the exception hierarchy is meant to work. Each plugin will build a product that is an instance of a Leaf. If a known or predictable error occurs, it will raise a `LeafError` (or some child or sibling of the LeafError). The leaf error is based on the `ApeError` rather than the `OperatorError` as `parts` of the `arachneape` will raise errors based on this as well so any part or plugin that has a predictable but unsalvageable error will cause the `Operation` to die but not the `Operator`, which will move on to the next Operation. If an Exception is raised that is not a sub-class of the `ApeError` then it is deemed unexpected and the `Operation` will not catch it, allowing the error to propagate  Because individual Operators should not affect each other, the Hortator will catch any Exceptions from the Operator and try to move on to the next Operator.

 * The `Operation` runs its `Leafs` and lets the errors propagate (so any raised will stop it)

 * The `Operator` runs its `Operations` and traps `ApeErrors` so that it can try all its `Operations`, allowing any clean-up `Leafs` to be run

 * The `Hortator` runs its `Operators` and traps all errors (except KeyboardInterrupts), preventing one `Operator` from stopping the others

<<name='test_imports', echo=False>>=
# python standard library
import unittest

# third-party
try:
    from mock import MagicMock
except ImportError:
    pass

# this package
from arachneape.commoncode.errors import ApeError
@
<<name='TestComponent', wrap=False>>=
class BadComponent(Component):
    def __init__(self):
        return

class BetterComponent(Component):
    def __call__(self):
        return

class TestComponent(unittest.TestCase):
    def setUp(self):
        self.composite = Composite()
        self.component = BetterComponent()
        return
    
    def test_bad_component(self):
        """
        Does it raise a TypeError if you do not implement the __call__?
        """
        self.assertRaises(TypeError, BadComponent)
        BetterComponent()
        return
@

<<name='TestComposite', wrap=False>>=
class TestComposite(unittest.TestCase):
    def setUp(self):
        self.composite = Composite()
        self.component = BetterComponent()
        return
    
    def test_add_component(self):
        self.composite.add(self.component)
        self.composite.add(self.component)
        self.assertEqual(1, len(self.composite))
        self.assertIn(self.component, self.composite)
        return

    def test_remove_component(self):
        self.composite.add(self.component)
        self.composite.remove(self.component)
        return

    def test_slice(self):
        self.composite.add(self.component)
        # indexing
        self.assertEqual(self.component, self.composite[-1])
        component = BetterComponent()
        self.composite.add(component)
        # slicing
        self.assertEqual([self.component, component], self.composite[:])
        return

    def test_check_rep(self):
        self.composite.error = ApeError
        self.composite.error_message = "Die antwoort ist nicht in die aufreissen."
        self.composite.component_category = "Piltdown Mann"
        # this should not raise an error
        self.composite.check_rep()

        # error cannot be None
        self.composite.error = None
        self.assertRaises(ConfigurationError, self.composite.check_rep)

        # error must be exception
        self.composite.error = Composite
        self.assertRaises(ConfigurationError, self.composite.check_rep)

        self.composite.error = ApeError
        self.composite.error_message = None
        self.assertRaises(ConfigurationError, self.composite.check_rep)

        self.composite.error_message = 'Ausgezeichnet.'
        self.composite.component_category = None
        self.assertRaises(ConfigurationError, self.composite.check_rep)
        return

@
<<name='TestHortator', wrap=False>>=
class TestHortator(unittest.TestCase):
    def setUp(self):
        self.hortator = Composite(error=Exception,
                                  error_message="Operator Crash",
                                  component_category='Operator')
        return

    def test_exception(self):
        bad_operator = MagicMock(side_effect =Exception('bad operator1'))        
        next_operator = MagicMock()
        self.hortator._logger = MagicMock()
        self.hortator.add(bad_operator)
        self.hortator.add(next_operator)
        self.hortator()
        return
@
<<name='TestOperator', wrap=False>>=
class TestOperator(unittest.TestCase):
    def setUp(self):
        self.operator = Composite(error=ApeError,
                                  error_message='Operation Crash',
                                  component_category='Operation')
        self.operator._logger = MagicMock()
        return

    def test_exception(self):
        component = MagicMock(side_effect=ApeError)
        component_2 = MagicMock()
        self.operator.add(component)
        self.operator.add(component_2)
        self.operator()
        # the composite should catch the ApeError and move on to component_2
        component_2.assert_called_with()

        # component_3 raises an Exception that should not be caught
        component_3 = MagicMock(side_effect=Exception)
        self.operator.add(component_3)

        # countdown isn't meant to re-run (bug?)
        self.operator._countdown = None

        self.assertEqual(3, len(self.operator))
        
        # but it should not catch an Exception
        self.assertRaises(Exception, self.operator)
        return
@
<%
for case in (TestComponent, TestHortator,
             TestOperator,
             TestComposite):
    suite = unittest.TestLoader().loadTestsFromTestCase(case)    
    unittest.TextTestRunner(verbosity=2).run(suite)
%>

.. autosummary::
   :toctree: api

   TestComponent.test_bad_component
